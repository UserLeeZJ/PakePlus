<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°ç‹¬å¤§å¸ˆ</title>
    <style>
        :root {
            --primary: #4F46E5;
            --primary-dark: #4338CA;
            --secondary: #6366F1;
            --accent: #C7D2FE;
            --light-accent: #E0E7FF;
            --background: #F5F5FF;
            --text: #1F2937;
            --light-text: #6B7280;
            --error: #EF4444;
            --success: #10B981;
            --warning: #F59E0B;
            --border: #D1D5DB;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, var(--background), #EDE9FE);
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            color: var(--text);
            line-height: 1.6;
        }

        .container {
            max-width: 600px;
            width: 100%;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 0 1rem;
        }

        header h1 {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(79, 70, 229, 0.1);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .stat-box {
            background: white;
            padding: 0.8rem 1.2rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--light-text);
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--primary);
            font-family: monospace;
        }

        .timer {
            font-family: monospace;
            font-size: 1.3rem;
            background: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: inline-block;
            font-weight: 600;
        }

        .mode-switch {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0;
            gap: 0.5rem;
            background: white;
            padding: 0.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .mode-switch button {
            padding: 0.6rem 1.5rem;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 0.5rem;
            background: transparent;
            color: var(--light-text);
        }

        .mode-switch button.active {
            background-color: var(--primary);
            color: white;
        }

        .game-board {
            background: white;
            border-radius: 1.25rem;
            padding: 1.75rem;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }

        .btn-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.65rem 1.25rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #f3f4f6;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        button:hover {
            background-color: #e5e7eb;
        }

        button.primary {
            background-color: var(--primary);
            color: white;
        }

        button.primary:hover {
            background-color: var(--primary-dark);
        }

        button.warning {
            background-color: var(--warning);
            color: white;
        }

        button.warning:hover {
            background-color: #e59e0b;
        }

        select {
            padding: 0.65rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: white;
            font-weight: 500;
            cursor: pointer;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 1px;
            background: #ccc;
            border: 2px solid #999;
            border-radius: 0.75rem;
            overflow: hidden;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .cell {
            aspect-ratio: 1/1;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: 500;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
        }

        .cell.fixed {
            font-weight: bold;
            color: var(--text);
            background-color: #f9fafb;
        }

        .cell.selected {
            outline: 2px solid var(--secondary);
            outline-offset: -2px;
            z-index: 2;
        }

        .cell.highlighted {
            background-color: var(--light-accent);
        }

        .cell.same-number {
            background-color: var(--accent);
        }

        .cell.error {
            color: var(--error);
            animation: pulse 0.5s;
        }

        .cell.notes {
            font-size: 0.75rem;
            color: var(--light-text);
            font-weight: normal;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 2px;
        }

        .note-number {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 1px solid #e5e7eb;
        }

        .cell.row-border::after {
            border-bottom: 2px solid #666;
        }

        .cell.col-border::after {
            border-right: 2px solid #666;
        }

        .number-buttons {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .number-button {
            aspect-ratio: 1/1;
            font-size: 1.2rem;
            font-weight: 600;
            background-color: var(--secondary);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .number-button:hover {
            background-color: var(--primary);
            transform: translateY(-2px);
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .action-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 0.8rem 0.5rem;
            background: #f3f4f6;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-button:hover {
            background: #e5e7eb;
            transform: translateY(-2px);
        }

        .action-button.active {
            background: var(--light-accent);
            box-shadow: 0 0 0 2px var(--secondary);
        }

        .action-button i {
            font-size: 1.2rem;
            color: var(--primary);
        }

        .action-button span {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
        }

        .footer {
            text-align: center;
            color: var(--light-text);
            font-size: 0.875rem;
            margin-top: 2rem;
            padding: 0 1rem;
        }

        /* Review mode styles */
        .review-board {
            display: none;
            background: white;
            border-radius: 1.25rem;
            padding: 1.75rem;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }

        .review-board h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .review-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 1px;
            background: #ccc;
            border: 2px solid #999;
            border-radius: 0.75rem;
            overflow: hidden;
            margin-bottom: 1.5rem;
        }

        .history-section {
            margin-top: 1.5rem;
        }

        .history-section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 1rem;
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .history-item {
            background: #f9fafb;
            padding: 0.8rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .history-item.active {
            background: var(--light-accent);
            border-left: 3px solid var(--primary);
        }

        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes celebrate {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .celebrate {
            animation: celebrate 0.5s ease-in-out;
        }

        /* Responsive design */
        @media (max-width: 640px) {
            .cell {
                font-size: 1.2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn-group {
                width: 100%;
                justify-content: center;
            }
            
            .stats {
                gap: 1rem;
            }
            
            .stat-box {
                min-width: 80px;
                padding: 0.6rem;
            }
            
            .stat-value {
                font-size: 1.2rem;
            }
            
            .number-button {
                font-size: 1rem;
            }
            
            .game-board, .review-board {
                padding: 1.25rem;
            }
        }

        @media (max-width: 480px) {
            header h1 {
                font-size: 2rem;
            }
            
            .cell {
                font-size: 1rem;
            }
            
            .number-button {
                font-size: 0.9rem;
            }
            
            button {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ•°ç‹¬å¤§å¸ˆ</h1>
            <div class="timer" id="timer">00:00</div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">éš¾åº¦</div>
                    <div class="stat-value" id="difficultyDisplay">ä¸­ç­‰</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">é”™è¯¯</div>
                    <div class="stat-value" id="mistakes">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">æç¤º</div>
                    <div class="stat-value" id="hints">3</div>
                </div>
            </div>
        </header>

        <div class="mode-switch">
            <button class="active" data-mode="play">å¯¹å±€</button>
            <button data-mode="review">å¤ç›˜</button>
            <button data-mode="help">å¸®åŠ©</button>
        </div>

        <!-- Game Board -->
        <div class="game-board" id="gameBoard">
            <div class="controls">
                <div class="btn-group">
                    <button class="primary" id="newGame">
                        <i>ğŸ²</i> æ–°æ¸¸æˆ
                    </button>
                    <select id="difficulty">
                        <option value="easy">ç®€å•</option>
                        <option value="medium" selected>ä¸­ç­‰</option>
                        <option value="hard">å›°éš¾</option>
                        <option value="expert">ä¸“å®¶</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button id="undo" disabled>
                        <i>â†©ï¸</i> æ’¤é”€
                    </button>
                    <button id="redo" disabled>
                        <i>â†ªï¸</i> é‡åš
                    </button>
                </div>
            </div>

            <div class="sudoku-grid" id="sudokuGrid"></div>

            <div class="number-buttons">
               
            </div>
            
            <div class="action-buttons">
                <div class="action-button" id="eraseButton">
                    <i>ğŸ§¹</i>
                    <span>æ“¦é™¤</span>
                </div>
                <div class="action-button" id="notesButton">
                    <i>ğŸ“</i>
                    <span>ç¬”è®°</span>
                </div>
                <div class="action-button" id="hintButton">
                    <i>ğŸ’¡</i>
                    <span>æç¤º</span>
                </div>
            </div>
        </div>

        <!-- Review Board -->
        <div class="review-board" id="reviewBoard">
            <h2>å¤ç›˜æ¨¡å¼</h2>
            <div class="review-grid" id="reviewGrid"></div>
            
            <div class="history-section">
                <h3>æ“ä½œå†å²</h3>
                <div class="history-list" id="historyList"></div>
            </div>
        </div>
        
        <!-- Help Board -->
        <div class="review-board" id="helpBoard" style="display: none;">
            <h2>æ¸¸æˆæŒ‡å—</h2>
            <div class="history-section">
                <h3>æ¸¸æˆè§„åˆ™</h3>
                <div class="history-item">
                    æ•°ç‹¬æ˜¯ä¸€ä¸ª9Ã—9çš„ç½‘æ ¼ï¼Œåˆ†ä¸º9ä¸ª3Ã—3çš„å­ç½‘æ ¼ã€‚æ¸¸æˆç›®æ ‡æ˜¯åœ¨æ¯ä¸ªæ ¼å­ä¸­å¡«å…¥1-9çš„æ•°å­—ï¼Œä½¿å¾—ï¼š
                </div>
                <div class="history-item">
                    1. æ¯ä¸€è¡ŒåŒ…å«1-9çš„æ‰€æœ‰æ•°å­—ï¼Œä¸”ä¸é‡å¤<br>
                    2. æ¯ä¸€åˆ—åŒ…å«1-9çš„æ‰€æœ‰æ•°å­—ï¼Œä¸”ä¸é‡å¤<br>
                    3. æ¯ä¸ª3Ã—3å­ç½‘æ ¼åŒ…å«1-9çš„æ‰€æœ‰æ•°å­—ï¼Œä¸”ä¸é‡å¤
                </div>
                
                <h3 style="margin-top: 1.5rem;">æ¸¸æˆåŠŸèƒ½</h3>
                <div class="history-item">
                    <strong>ç¬”è®°æ¨¡å¼</strong>ï¼šç‚¹å‡»ç¬”è®°æŒ‰é’®å¼€å¯ï¼Œå¯åœ¨å•å…ƒæ ¼ä¸­æ·»åŠ å°æ•°å­—ä½œä¸ºç¬”è®°
                </div>
                <div class="history-item">
                    <strong>æç¤º</strong>ï¼šç‚¹å‡»æç¤ºæŒ‰é’®ï¼Œç„¶åç‚¹å‡»ä¸€ä¸ªç©ºæ ¼ï¼Œç³»ç»Ÿä¼šä¸ºä½ å¡«å…¥æ­£ç¡®æ•°å­—ï¼ˆæ¯å±€æ¸¸æˆé™3æ¬¡ï¼‰
                </div>
                <div class="history-item">
                    <strong>é”™è¯¯æ£€æµ‹</strong>ï¼šç³»ç»Ÿä¼šè‡ªåŠ¨æ£€æµ‹å¹¶æ ‡è®°å†²çªçš„æ•°å­—
                </div>
            </div>
        </div>

        <footer class="footer">
            <p>æ•°ç‹¬å¤§å¸ˆ v2.0 - äº«å—æ™ºåŠ›æŒ‘æˆ˜çš„ä¹è¶£</p>
        </footer>
    </div>

    <script>
        // æ¸¸æˆå¸¸é‡
        const SUDOKU_SIZE = 9;
        const SUBGRID_SIZE = 3;
        const EMPTY_CELL = 0;
        
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            selectedCell: null,
            timer: 0,
            isRunning: false,
            interval: null,
            history: [],
            stepIndex: -1,
            currentMode: 'play',
            currentDifficulty: 'medium',
            mistakes: 0,
            hints: 3,
            notesMode: false,
            gameCompleted: false
        };

        // æ•°ç‹¬æ•°æ®
        let sudokuData = {
            puzzle: [],
            solution: [],
            fixedCells: [],
            userSolution: []
        };

        // DOM å…ƒç´ å¼•ç”¨
        const elements = {
            timer: document.getElementById('timer'),
            sudokuGrid: document.getElementById('sudokuGrid'),
            reviewGrid: document.getElementById('reviewGrid'),
            historyList: document.getElementById('historyList'),
            difficultyDisplay: document.getElementById('difficultyDisplay'),
            mistakes: document.getElementById('mistakes'),
            hints: document.getElementById('hints'),
            undo: document.getElementById('undo'),
            redo: document.getElementById('redo'),
            eraseButton: document.getElementById('eraseButton'),
            notesButton: document.getElementById('notesButton'),
            hintButton: document.getElementById('hintButton')
        };

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
		
			initNumberButtons();
            generateSudoku(gameState.currentDifficulty);
            renderGameBoard();
            resetGameState();
            startTimer();
            updateUI();
            addEventListeners();
        }

        // ç”Ÿæˆæ•°ç‹¬è°œé¢˜
        function generateSudoku(difficulty = 'medium') {
            // ç”Ÿæˆå®Œæ•´æ•°ç‹¬è§£å†³æ–¹æ¡ˆ
            const solution = generateCompleteSudoku();
            
            // åˆ›å»ºè°œé¢˜å‰¯æœ¬
            const puzzle = JSON.parse(JSON.stringify(solution));
            
            // æ ¹æ®éš¾åº¦ç§»é™¤å•å…ƒæ ¼
            removeCells(puzzle, difficulty);
            
            // ä¿å­˜æ•°ç‹¬æ•°æ®
            sudokuData = {
                solution: solution,
                puzzle: puzzle,
                fixedCells: puzzle.map(row => row.map(val => val !== EMPTY_CELL)),
                userSolution: JSON.parse(JSON.stringify(puzzle))
            };
        }

        // ç”Ÿæˆå®Œæ•´æ•°ç‹¬è§£å†³æ–¹æ¡ˆ
        function generateCompleteSudoku() {
            const grid = Array(SUDOKU_SIZE).fill().map(() => Array(SUDOKU_SIZE).fill(EMPTY_CELL));
            
            // å¡«å……å¯¹è§’çº¿ç›’å­ï¼ˆå½¼æ­¤ç‹¬ç«‹ï¼‰
            for (let i = 0; i < SUDOKU_SIZE; i += SUBGRID_SIZE) {
                fillBox(grid, i, i);
            }
            
            // å¡«å……å‰©ä½™å•å…ƒæ ¼
            fillRemaining(grid, 0, SUBGRID_SIZE);
            
            return grid;
        }

        // å¡«å……ä¸€ä¸ª3x3ç›’å­
        function fillBox(grid, row, col) {
            const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            
            for (let i = 0; i < SUBGRID_SIZE; i++) {
                for (let j = 0; j < SUBGRID_SIZE; j++) {
                    grid[row + i][col + j] = nums.pop();
                }
            }
        }

        // å¡«å……å‰©ä½™å•å…ƒæ ¼
        function fillRemaining(grid, row, col) {
            // å¦‚æœå·²åˆ°è¾¾ç½‘æ ¼æœ«å°¾ï¼Œè¿”å›æˆåŠŸ
            if (row === SUDOKU_SIZE - 1 && col === SUDOKU_SIZE) {
                return true;
            }
            
            // ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œ
            if (col === SUDOKU_SIZE) {
                row++;
                col = 0;
            }
            
            // å¦‚æœå•å…ƒæ ¼å·²æœ‰å€¼ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
            if (grid[row][col] !== EMPTY_CELL) {
                return fillRemaining(grid, row, col + 1);
            }
            
            // å°è¯•1-9çš„æ•°å­—
            for (let num = 1; num <= SUDOKU_SIZE; num++) {
                if (isSafe(grid, row, col, num)) {
                    grid[row][col] = num;
                    
                    // é€’å½’å¡«å……ä¸‹ä¸€ä¸ªå•å…ƒæ ¼
                    if (fillRemaining(grid, row, col + 1)) {
                        return true;
                    }
                    
                    // å›æº¯
                    grid[row][col] = EMPTY_CELL;
                }
            }
            
            return false;
        }

        // æ£€æŸ¥æ•°å­—æ˜¯å¦å¯ä»¥å®‰å…¨æ”¾ç½®
        function isSafe(grid, row, col, num) {
            // æ£€æŸ¥è¡Œ
            if (grid[row].includes(num)) return false;
            
            // æ£€æŸ¥åˆ—
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                if (grid[i][col] === num) return false;
            }
            
            // æ£€æŸ¥3x3å­ç½‘æ ¼
            const boxRow = Math.floor(row / SUBGRID_SIZE) * SUBGRID_SIZE;
            const boxCol = Math.floor(col / SUBGRID_SIZE) * SUBGRID_SIZE;
            
            for (let r = 0; r < SUBGRID_SIZE; r++) {
                for (let c = 0; c < SUBGRID_SIZE; c++) {
                    if (grid[boxRow + r][boxCol + c] === num) return false;
                }
            }
            
            return true;
        }

        // éšæœºæ’åˆ—æ•°ç»„
        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // æ ¹æ®éš¾åº¦ç§»é™¤å•å…ƒæ ¼
        function removeCells(grid, difficulty) {
            const removals = {
                easy: 35,
                medium: 45,
                hard: 55,
                expert: 60
            };
            
            let cellsToRemove = removals[difficulty] || 45;
            
            // è·å–æ‰€æœ‰å•å…ƒæ ¼ä½ç½®
            let positions = [];
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    positions.push({ row, col });
                }
            }
            
            // éšæœºæ‰“ä¹±ä½ç½®
            positions = shuffle(positions);
            
            // ç§»é™¤å•å…ƒæ ¼
            for (let i = 0; i < cellsToRemove; i++) {
                const { row, col } = positions[i];
                grid[row][col] = EMPTY_CELL;
            }
        }

        // æ¸²æŸ“æ¸¸æˆæ£‹ç›˜
        function renderGameBoard() {
            elements.sudokuGrid.innerHTML = '';
            
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // æ·»åŠ è¾¹æ¡†ç±»
                    if (row % SUBGRID_SIZE === SUBGRID_SIZE - 1 && row < SUDOKU_SIZE - 1) {
                        cell.classList.add('row-border');
                    }
                    if (col % SUBGRID_SIZE === SUBGRID_SIZE - 1 && col < SUDOKU_SIZE - 1) {
                        cell.classList.add('col-border');
                    }
                    
                    // å›ºå®šå•å…ƒæ ¼æ ·å¼
                    if (sudokuData.fixedCells[row][col]) {
                        cell.classList.add('fixed');
                    }
                    
                    // è®¾ç½®å•å…ƒæ ¼å†…å®¹
                    const cellValue = sudokuData.userSolution[row][col];
                    if (cellValue !== EMPTY_CELL) {
                        cell.textContent = cellValue;
                    }
                    
                    // è®¾ç½®æ•°æ®å±æ€§
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    
                    elements.sudokuGrid.appendChild(cell);
                }
            }
        }

        // å¤„ç†å•å…ƒæ ¼ç‚¹å‡»
        function handleCellClick(row, col) {
            if (gameState.gameCompleted) return;
            if (sudokuData.fixedCells[row][col]) return;
            
            // ç§»é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            // æ·»åŠ æ–°çš„é€‰ä¸­çŠ¶æ€
            gameState.selectedCell = { row, col };
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            cell.classList.add('selected');
            
            // é«˜äº®ç›¸åŒæ•°å­—
            highlightSameNumbers(sudokuData.userSolution[row][col]);
        }

        // é«˜äº®ç›¸åŒæ•°å­—
        function highlightSameNumbers(number) {
            if (number === EMPTY_CELL) return;
            
            // ç§»é™¤ä¹‹å‰çš„é«˜äº®
            document.querySelectorAll('.cell.same-number').forEach(cell => {
                cell.classList.remove('same-number');
            });
            
            // é«˜äº®ç›¸åŒæ•°å­—çš„å•å…ƒæ ¼
            document.querySelectorAll('.cell').forEach(cell => {
                const cellValue = parseInt(cell.textContent) || EMPTY_CELL;
                if (cellValue === number) {
                    cell.classList.add('same-number');
                }
            });
        }

        // å¤„ç†æ•°å­—é€‰æ‹©
        function handleNumberSelect(num) {
            if (!gameState.selectedCell) return;
            if (gameState.gameCompleted) return;
            
            const { row, col } = gameState.selectedCell;
            if (sudokuData.fixedCells[row][col]) return;
            
            const currentVal = sudokuData.userSolution[row][col];
            
            // å¦‚æœç¬”è®°æ¨¡å¼å¼€å¯
            if (gameState.notesMode) {
                toggleNote(row, col, num);
                return;
            }
            
            // å¦‚æœé€‰æ‹©çš„æ˜¯å½“å‰å€¼ï¼Œåˆ™æ¸…é™¤
            if (currentVal === num) {
                num = EMPTY_CELL;
            }
            
            // æ£€æŸ¥å†²çª
            const conflict = checkConflict(row, col, num);
            
            // åˆ›å»ºæ–°å†å²è®°å½•
            const newHistory = gameState.history.slice(0, gameState.stepIndex + 1);
            newHistory.push({ row, col, oldVal: currentVal, newVal: num, conflict });
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.history = newHistory;
            gameState.stepIndex = newHistory.length - 1;
            
            // æ›´æ–°æ•°ç‹¬æ•°æ®
            sudokuData.userSolution[row][col] = num;
            
            // æ›´æ–°ç•Œé¢æ˜¾ç¤º
            updateCell(row, col, num);
            
            // é«˜äº®ç›¸åŒæ•°å­—
            highlightSameNumbers(num);
            
            // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
            checkWin();
            
            // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
            updateHistoryButtons();
        }

        // æ›´æ–°å•å…ƒæ ¼æ˜¾ç¤º
        function updateCell(row, col, value) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            
            // æ¸…é™¤ç¬”è®°å’Œé”™è¯¯çŠ¶æ€
            cell.classList.remove('notes', 'error');
            
            // è®¾ç½®æ–°å€¼
            if (value === EMPTY_CELL) {
                cell.textContent = '';
            } else {
                cell.textContent = value;
                
                // æ£€æŸ¥å†²çª
                if (checkConflict(row, col, value)) {
                    cell.classList.add('error');
                    gameState.mistakes++;
                    elements.mistakes.textContent = gameState.mistakes;
                }
            }
        }

        // æ£€æŸ¥æ•°å­—å†²çª
        function checkConflict(row, col, num) {
            if (num === EMPTY_CELL) return false;
            
            // æ£€æŸ¥è¡Œå†²çª
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (c !== col && sudokuData.userSolution[row][c] === num) {
                    return true;
                }
            }
            
            // æ£€æŸ¥åˆ—å†²çª
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                if (r !== row && sudokuData.userSolution[r][col] === num) {
                    return true;
                }
            }
            
            // æ£€æŸ¥3x3å­ç½‘æ ¼å†²çª
            const boxRow = Math.floor(row / SUBGRID_SIZE) * SUBGRID_SIZE;
            const boxCol = Math.floor(col / SUBGRID_SIZE) * SUBGRID_SIZE;
            
            for (let r = 0; r < SUBGRID_SIZE; r++) {
                for (let c = 0; c < SUBGRID_SIZE; c++) {
                    const cellRow = boxRow + r;
                    const cellCol = boxCol + c;
                    
                    if (cellRow !== row && cellCol !== col && 
                        sudokuData.userSolution[cellRow][cellCol] === num) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // åˆ‡æ¢ç¬”è®°
        function toggleNote(row, col, num) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            
            // å¦‚æœå•å…ƒæ ¼ä¸æ˜¯ç¬”è®°æ¨¡å¼ï¼Œåˆå§‹åŒ–ç¬”è®°
            if (!cell.classList.contains('notes')) {
                cell.classList.add('notes');
                cell.innerHTML = '';
                
                // åˆ›å»º3x3ç½‘æ ¼ç”¨äºç¬”è®°
                for (let i = 1; i <= 9; i++) {
                    const noteNum = document.createElement('div');
                    noteNum.className = 'note-number';
                    noteNum.textContent = i;
                    noteNum.dataset.note = i;
                    cell.appendChild(noteNum);
                }
            }
            
            // åˆ‡æ¢ç¬”è®°æ•°å­—
            const noteNum = cell.querySelector(`.note-number[data-note="${num}"]`);
            if (noteNum.style.visibility === 'hidden') {
                noteNum.style.visibility = 'visible';
            } else {
                noteNum.style.visibility = 'hidden';
            }
        }

        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
        function checkWin() {
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    if (sudokuData.userSolution[row][col] === EMPTY_CELL || 
                        sudokuData.userSolution[row][col] !== sudokuData.solution[row][col]) {
                        return false;
                    }
                }
            }
            
            // èƒœåˆ©å¤„ç†
            gameState.gameCompleted = true;
            stopTimer();
            
            // æ·»åŠ åº†ç¥åŠ¨ç”»
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.add('celebrate');
            });
            
            setTimeout(() => {
                alert('æ­å–œï¼ä½ æˆåŠŸå®Œæˆäº†æ•°ç‹¬ï¼');
            }, 500);
            
            return true;
        }

        // æ’¤é”€æ“ä½œ
        function undo() {
            if (gameState.stepIndex >= 0) {
                const step = gameState.history[gameState.stepIndex];
                
                // æ›´æ–°æ•°ç‹¬æ•°æ®
                sudokuData.userSolution[step.row][step.col] = step.oldVal;
                
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                gameState.stepIndex--;
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                updateCell(step.row, step.col, step.oldVal);
                
                // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
                updateHistoryButtons();
            }
        }

        // é‡åšæ“ä½œ
        function redo() {
            if (gameState.stepIndex < gameState.history.length - 1) {
                gameState.stepIndex++;
                const step = gameState.history[gameState.stepIndex];
                
                // æ›´æ–°æ•°ç‹¬æ•°æ®
                sudokuData.userSolution[step.row][step.col] = step.newVal;
                
                // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                updateCell(step.row, step.col, step.newVal);
                
                // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
                updateHistoryButtons();
            }
        }

        // ä½¿ç”¨æç¤º
        function useHint() {
            if (gameState.hints <= 0) {
                alert('æ²¡æœ‰å¯ç”¨çš„æç¤ºäº†ï¼');
                return;
            }
            
            if (!gameState.selectedCell) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå•å…ƒæ ¼ï¼');
                return;
            }
            
            const { row, col } = gameState.selectedCell;
            
            // å¦‚æœå•å…ƒæ ¼å·²æœ‰æ­£ç¡®å€¼ï¼Œä¸éœ€è¦æç¤º
            if (sudokuData.userSolution[row][col] === sudokuData.solution[row][col]) {
                alert('è¿™ä¸ªå•å…ƒæ ¼å·²ç»æ˜¯æ­£ç¡®çš„äº†ï¼');
                return;
            }
            
            // è·å–æ­£ç¡®æ•°å­—
            const correctNum = sudokuData.solution[row][col];
            
            // åˆ›å»ºå†å²è®°å½•
            const newHistory = gameState.history.slice(0, gameState.stepIndex + 1);
            newHistory.push({ 
                row, 
                col, 
                oldVal: sudokuData.userSolution[row][col], 
                newVal: correctNum,
                isHint: true
            });
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.history = newHistory;
            gameState.stepIndex = newHistory.length - 1;
            gameState.hints--;
            
            // æ›´æ–°æ•°ç‹¬æ•°æ®
            sudokuData.userSolution[row][col] = correctNum;
            
            // æ›´æ–°ç•Œé¢æ˜¾ç¤º
            updateCell(row, col, correctNum);
            elements.hints.textContent = gameState.hints;
            
            // é«˜äº®ç›¸åŒæ•°å­—
            highlightSameNumbers(correctNum);
            
            // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
            checkWin();
            
            // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
            updateHistoryButtons();
        }

        // æ“¦é™¤å•å…ƒæ ¼
        function eraseCell() {
            if (!gameState.selectedCell) return;
            
            const { row, col } = gameState.selectedCell;
            if (sudokuData.fixedCells[row][col]) return;
            
            // åˆ›å»ºå†å²è®°å½•
            const newHistory = gameState.history.slice(0, gameState.stepIndex + 1);
            newHistory.push({ 
                row, 
                col, 
                oldVal: sudokuData.userSolution[row][col], 
                newVal: EMPTY_CELL 
            });
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.history = newHistory;
            gameState.stepIndex = newHistory.length - 1;
            
            // æ›´æ–°æ•°ç‹¬æ•°æ®
            sudokuData.userSolution[row][col] = EMPTY_CELL;
            
            // æ›´æ–°ç•Œé¢æ˜¾ç¤º
            updateCell(row, col, EMPTY_CELL);
            
            // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
            updateHistoryButtons();
        }

        // åˆ‡æ¢ç¬”è®°æ¨¡å¼
        function toggleNotesMode() {
            gameState.notesMode = !gameState.notesMode;
            elements.notesButton.classList.toggle('active', gameState.notesMode);
        }

        // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
        function updateHistoryButtons() {
            elements.undo.disabled = gameState.stepIndex < 0;
            elements.redo.disabled = gameState.stepIndex >= gameState.history.length - 1;
        }
		function initNumberButtons() {
			const container = document.querySelector('.number-buttons');
			container.innerHTML = '';
			
			for (let i = 1; i <= 9; i++) {
				const button = document.createElement('button');
				button.className = 'number-button';
				button.dataset.number = i;
				button.textContent = i;
				button.addEventListener('click', () => handleNumberSelect(i));
				container.appendChild(button);
			}
		}



        // é‡ç½®æ¸¸æˆçŠ¶æ€
        function resetGameState() {
            gameState.selectedCell = null;
            gameState.history = [];
            gameState.stepIndex = -1;
            gameState.mistakes = 0;
            gameState.hints = 3;
            gameState.notesMode = false;
            gameState.gameCompleted = false;
            
            elements.mistakes.textContent = '0';
            elements.hints.textContent = '3';
            elements.notesButton.classList.remove('active');
        }

        // è®¡æ—¶å™¨å‡½æ•°
        function startTimer() {
            if (gameState.interval) clearInterval(gameState.interval);
            gameState.timer = 0;
            gameState.isRunning = true;
            gameState.interval = setInterval(() => {
                gameState.timer++;
                elements.timer.textContent = formatTime(gameState.timer);
            }, 1000);
        }

        function stopTimer() {
            gameState.isRunning = false;
            clearInterval(gameState.interval);
        }

        function resetTimer() {
            stopTimer();
            gameState.timer = 0;
            elements.timer.textContent = '00:00';
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // åˆ‡æ¢æ¨¡å¼
        function switchMode(mode) {
            gameState.currentMode = mode;
            
            // æ›´æ–°æ¨¡å¼æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.mode-switch button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            
            // æ˜¾ç¤º/éšè—å¯¹åº”é¢æ¿
            document.getElementById('gameBoard').style.display = mode === 'play' ? 'block' : 'none';
            document.getElementById('reviewBoard').style.display = mode === 'review' ? 'block' : 'none';
            document.getElementById('helpBoard').style.display = mode === 'help' ? 'block' : 'none';
            
            // æ¸²æŸ“å¤ç›˜é¢æ¿
            if (mode === 'review') {
                renderReviewBoard();
            }
        }

        // æ¸²æŸ“å¤ç›˜é¢æ¿
        function renderReviewBoard() {
            elements.reviewGrid.innerHTML = '';
            
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell fixed';
                    
                    // æ·»åŠ è¾¹æ¡†ç±»
                    if (row % SUBGRID_SIZE === SUBGRID_SIZE - 1 && row < SUDOKU_SIZE - 1) {
                        cell.classList.add('row-border');
                    }
                    if (col % SUBGRID_SIZE === SUBGRID_SIZE - 1 && col < SUDOKU_SIZE - 1) {
                        cell.classList.add('col-border');
                    }
                    
                    // è®¾ç½®å•å…ƒæ ¼å†…å®¹
                    cell.textContent = sudokuData.solution[row][col];
                    elements.reviewGrid.appendChild(cell);
                }
            }
            
            // æ¸²æŸ“å†å²è®°å½•
            elements.historyList.innerHTML = '';
            
            gameState.history.forEach((step, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                if (index <= gameState.stepIndex) {
                    historyItem.classList.add('active');
                }
                
                if (step.isHint) {
                    historyItem.textContent = `ç¬¬ ${index + 1} æ­¥ï¼šåœ¨ (${step.row+1},${step.col+1}) ä½¿ç”¨æç¤ºå¡«å…¥ ${step.newVal}`;
                } else {
                    historyItem.textContent = `ç¬¬ ${index + 1} æ­¥ï¼šåœ¨ (${step.row+1},${step.col+1}) å°† ${step.oldVal || 'ç©º'} æ”¹ä¸º ${step.newVal}`;
                }
                
                elements.historyList.appendChild(historyItem);
            });
        }

        // æ›´æ–°UI
        function updateUI() {
            elements.difficultyDisplay.textContent = {
                easy: 'ç®€å•',
                medium: 'ä¸­ç­‰',
                hard: 'å›°éš¾',
                expert: 'ä¸“å®¶'
            }[gameState.currentDifficulty];
        }

        // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        function addEventListeners() {
            // æ–°æ¸¸æˆæŒ‰é’®
            document.getElementById('newGame').addEventListener('click', () => {
                initGame();
            });
            
            // éš¾åº¦é€‰æ‹©
            document.getElementById('difficulty').addEventListener('change', (e) => {
                gameState.currentDifficulty = e.target.value;
                initGame();
                updateUI();
            });
            
            // æ•°å­—æŒ‰é’®
            document.querySelectorAll('.number-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    handleNumberSelect(parseInt(e.target.dataset.number));
                });
            });
            
            // æ’¤é”€/é‡åšæŒ‰é’®
            elements.undo.addEventListener('click', undo);
            elements.redo.addEventListener('click', redo);
            
            // æ¨¡å¼åˆ‡æ¢
            document.querySelectorAll('.mode-switch button').forEach(button => {
                button.addEventListener('click', () => {
                    switchMode(button.dataset.mode);
                });
            });
            
            // åŠ¨ä½œæŒ‰é’®
            elements.eraseButton.addEventListener('click', eraseCell);
            elements.notesButton.addEventListener('click', toggleNotesMode);
            elements.hintButton.addEventListener('click', useHint);
            
            // é”®ç›˜æ”¯æŒ
            document.addEventListener('keydown', (e) => {
                if (gameState.currentMode !== 'play') return;
                
                const key = e.key;
                
                // æ•°å­—1-9
                if (/^[1-9]$/.test(key)) {
                    handleNumberSelect(parseInt(key));
                }
                
                // åˆ é™¤/é€€æ ¼é”®
                if (key === 'Delete' || key === 'Backspace') {
                    eraseCell();
                }
                
                // æ–¹å‘é”®ç§»åŠ¨é€‰æ‹©
                if (gameState.selectedCell) {
                    const { row, col } = gameState.selectedCell;
                    let newRow = row, newCol = col;
                    
                    if (key === 'ArrowUp' && row > 0) newRow--;
                    if (key === 'ArrowDown' && row < 8) newRow++;
                    if (key === 'ArrowLeft' && col > 0) newCol--;
                    if (key === 'ArrowRight' && col < 8) newCol++;
                    
                    if (newRow !== row || newCol !== col) {
                        handleCellClick(newRow, newCol);
                    }
                }
            });
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>